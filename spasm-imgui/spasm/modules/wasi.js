// File is autogenerated with `dub run spasm:bootstrap-webpack`
import {spasm as spa, decoders as decoder, encoders as encoder} from './spasm.js';

let spasm = spa;
const nodes = spasm.objects;
const addPtr = spasm.addObject;

export let jsExports = {
    wasi_unstable: {
        fd_write: (fd,//: wasm32::__wasi_fd_t,
                   iovs,//: wasm32::uintptr_t,
                   iovs_len,//: wasm32::size_t,
                   nwritten//: wasm32::uintptr_t
                  ) => {
                      let written = 0;
                      const heapi32u = new Uint32Array(spasm.memory.buffer)
                      for(var i = 0; i < iovs_len; i++) {
                          var buf = heapi32u[(iovs+i*8) / 4];
                          var len = heapi32u[(iovs+i*8) / 4 + 1];
                          if (len > 0) {
                              var str = decoder.string(len, buf);
                              written += len;
                          }
                      }
                      heapi32u[nwritten/4] = written;
                      return 0;
                  },
        fd_seek: (fd, //: wasm32::__wasi_fd_t,
                  offset, //: wasm32::__wasi_filedelta_t,
                  whence, //: wasm32::__wasi_whence_t,
                  newoffset //: wasm32::uintptr_t
                 ) => {
                     return 0;
                 },
        fd_close: (fd, //: wasm32::__wasi_fd_t)
                  ) => {
                      return 0;
                  },
        fd_fdstat_get: (fd,//: wasm32::__wasi_fd_t,
                        buf,//: wasm32::uintptr_t,
                       ) => {
                           const heapi8u = new Uint8Array(spasm.memory.buffer)
                           const heapi16u = new Uint16Array(spasm.memory.buffer)
                           const heapi32u = new Uint32Array(spasm.memory.buffer)
                           heapi8u[buf] = 0x60; // filetype
                           heapi16u[buf / 2] = 0x01 | 0x10; //fdflags
                           heapi32u[buf+1] = 0x40 | 0x4000; // uint64 rights
                           heapi32u[buf+1] = 0x40 | 0x4000; // uint64 rights_inheriting
                           return 0;
                       },
        path_open: () => {
            return 0;
        },
        fd_fdstat_set_flags: () => 0,
        fd_read: () => 0
    }
}
